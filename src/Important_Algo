1. Fisher Yates  Shuffling Algorithm [ https://leetcode.com/problems/linked-list-random-node/solution/ ]
2. Reservior Sampling Algorithm [  https://youtu.be/DC2el-eDNi4    ]
3. Fenwick Tree [ https://youtu.be/DPiY9wFxGIw ] 
4. KMP ALGORITHM [ https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/ ]
5. Rabin Karp Using  Rolling Hash [ https://youtu.be/H4VrKHVG5qI ] 
6. Why use a prime number in hashCode ? [ A prime number can only be divided by 1 or itself, so it cannot be factored any further! Every other whole number can be broken down into prime number factors. ]
7. Bit Manipulation Good Problem  [ https://leetcode.com/problems/set-mismatch/ ]

public class Solution {
    public int[] findErrorNums(int[] nums) {
        int xor = 0, xor0 = 0, xor1 = 0;
        for (int n: nums)
            xor ^= n;
        for (int i = 1; i <= nums.length; i++)
            xor ^= i;
        int rightmostbit = xor & ~(xor - 1);
        for (int n: nums) {
            if ((n & rightmostbit) != 0)
                xor1 ^= n;
            else
                xor0 ^= n;
        }
        for (int i = 1; i <= nums.length; i++) {
            if ((i & rightmostbit) != 0)
                xor1 ^= i;
            else
                xor0 ^= i;
        }
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == xor0)
                return new int[]{xor0, xor1};
        }
        return new int[]{xor1, xor0};
    }
}





8 . [ 1542. Find Longest Awesome Substring ] [ https://leetcode.com/problems/find-longest-awesome-substring/ ]


9.  [  1109. Corporate Flight Bookings  ]  [ https://leetcode.com/problems/corporate-flight-bookings/ ]



class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int result[]=new int[n];
        for(int booking[]:bookings){
            result[booking[0]-1]+=booking[2];
            if(booking[1]<n)
                result[booking[1]]-=booking[2];
        }
        for(int i=1;i<n;i++)
            result[i]+=result[i-1];
        return result;
        
    }
}




10 . EULER TRAIL AND CIRCUIT [ BCZ EULER PATH PATH KI DEFINITION KO VIOLATE KARTA HAI ISLIYE KAI JAGAH YE TRAIL SE BHI BHULAYA JAATA HAI ] [ https://youtu.be/8MpoO2zA2l4 ]


problem :- https://leetcode.com/problems/valid-arrangement-of-pairs/




11 . Count of Smaller Numbers After Self  [ https://leetcode.com/problems/count-of-smaller-numbers-after-self/ ]




12. To cluster two groups [ https://leetcode.com/problems/sort-array-by-parity/ ]



class Solution {
    public int[] sortArrayByParity(int[] nums) {
        
        int i=0,j=nums.length-1;
        while(i<j){
            if((nums[i]&1)==0){
                i++;
            }
            else{
                int temp=nums[j];
                nums[j]=nums[i];
                nums[i]=temp;
                j--;
            }
        }
        return nums;
        
        
        
        
    }
}

13 . Three clusters can also be done in the similar fashion [ see Sorting Colors problem ]




14 .  Minimum Numbers of Function Calls to Make Target Array   [  https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/ ]


class Solution {
    public int minOperations(int[] nums) {
        int op=0;
        for(int i=0;i<32;i++){
        
            boolean flag=false;
        for(int j=0;j<nums.length;j++){
            op+=nums[j]%2;
            nums[j]/=2;
            flag|=(nums[j]>0);
        }
        if(flag) op++; else break;
    }
     return op;   
    }
}





https://leetcode.com/problems/search-in-rotated-sorted-array-ii/

https://leetcode.com/problems/search-in-rotated-sorted-array/














15 . [ IMP ] 834. Sum of Distances in Tree   [ https://leetcode.com/problems/sum-of-distances-in-tree/  ]

class Solution {
    
    HashMap<Integer,ArrayList<Integer>> map;
    int count[],ans[];
    public int[] sumOfDistancesInTree(int n, int[][] edges) {
        map=new HashMap<>();
        for(int i=0;i<n;i++)
            map.put(i,new ArrayList<Integer>());
        for(int i[]:edges){
            map.get(i[0]).add(i[1]);
            map.get(i[1]).add(i[0]);
        }
        count=new int[n];
        ans=new int[n];
        Arrays.fill(count,1);
        dfs(0,-1,0);
        dfs2(0,-1);
        return ans;
        
    }
    
    
    void dfs(int node,int parent,int level){
        ans[0]+=level;
        for(int i:map.get(node)){
            if(i!=parent){
               dfs(i,node,level+1);
               count[node]+=count[i];
            }
        }  
    }
    
    void dfs2(int node,int parent){
        for(int i:map.get(node)){
            if(i!=parent){
                ans[i]=ans[node]+count.length-2*count[i];
                dfs2(i,node);
                
            }
        }
        
    }
    
    
}

16 . [ 1825. Finding MK Average ] [ https://leetcode.com/problems/finding-mk-average/ ] 

class MKAverage {

  int sum,total,m,k;

    TreeMap<Integer,Integer> map=new TreeMap<>();
    Queue<Integer> queue=new LinkedList<>();
    public MKAverage(int m, int k) {

       this.m=m;
       this.k=k;
    }

    public void addElement(int num) {

       total++;
       sum+=num;
       queue.add(num);
       map.put(num,map.getOrDefault(num,0)+1);
       if (total>m){
           total--;
          int first=queue.poll();
          sum-=first;
          if (map.get(first)==1)
             map.remove(first);
          else map.put(first,map.get(first)-1);

       }


    }

    public int calculateMKAverage() {

       if (total<m) return -1;

       int count=k;
       int temp_sum=sum;
       for (Map.Entry<Integer,Integer> entry:map.entrySet()){
          if (count==0) break;
          int val=entry.getValue();
          int key=entry.getKey();
          int min=Math.min(count,val);
          count-=min;
          temp_sum-=min*key;

       }
       count=k;
       for (Map.Entry<Integer,Integer> entry:map.descendingMap().entrySet()){
          if (count==0) break;
          int val=entry.getValue();
          int key=entry.getKey();
          int min=Math.min(count,val);
          count-=min;
          temp_sum-=min*key;
       }


       return temp_sum/(m-2*k);
    }
}




17 .  Find Median from Data Stream [ https://leetcode.com/problems/find-median-from-data-stream/ ]




class MedianFinder {

    PriorityQueue<Integer> left,right;
    public MedianFinder() {
        left=new PriorityQueue<>(Collections.reverseOrder());
        right=new PriorityQueue<>();
    }

     public void addNum(int num) {
        if (left.size()==0) {
            left.add(num);
            return;
        }
        else if (right.size()==0){
            if (left.peek()>num) {
                right.add(left.poll());
                left.add(num);
            }
            else right.add(num);
            return;
        }

        if (left.peek()>num){
            if (left.size()!=right.size()){
                right.add(left.poll());
            }
            left.add(num);
        }
        else if (right.peek()<num){
            if (left.size()==right.size()){
                left.add(right.poll());
            }
            right.add(num);
        }
        else {
            if (left.size()==right.size()) left.add(num);
            else right.add(num);
        }
    }

    public double findMedian() {
        return left.size()==right.size()?((double)left.peek()+ right.peek())/2: left.peek();
    }

}


18 . Minimum Garden Perimeter to Collect Enough Apples [ https://leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/ ]


class Solution {
    
    long totalapple(long n){
        return 2 * (n*(n+1)*(2*n + 1));
    }
    
    
    public long minimumPerimeter(long neededApples) {
        long low=0,high=1000000;
        while(low<high){
            long mid=(low+high)/2;
            if(totalapple(mid)<neededApples){
                low=mid+1;
            }
            else{
                high=mid;
            }
        }
        return low*8;
    }
}


19 . Minimum Difference in Sums After Removal of Elements [ https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/ ]


class Solution {
    public long minimumDifference(int[] nums) {

         int n=nums.length/3;
        PriorityQueue<Integer> queue=new PriorityQueue<>(Collections.reverseOrder());
        long leftsum=0;
        for (int i=0;i<n;i++)
        {
            leftsum+=nums[i];
            queue.add(nums[i]);
        }
        long dp[]=new long[n+1];
        for (int i=n;i<=2*n;i++){
            dp[i-n]=leftsum;
            queue.add(nums[i]);
            leftsum+=(nums[i]-queue.poll());
        }
        queue=new PriorityQueue<>();
        long rightsum=0;
        for (int i=3*n-1;i>=2*n;i--)
        {
            rightsum+=nums[i];
            queue.add(nums[i]);
        }

        long res=dp[dp.length-1]-rightsum;
        for (int i=2*n-1;i>=n;i--){
           
            queue.add(nums[i]);
            rightsum+=(nums[i]-queue.poll());
            res=Math.min(res,dp[i-n]-rightsum);
            
        }


        return res;
    }
}




20. Minimize Deviation in Array  [ https://leetcode.com/problems/minimize-deviation-in-array/ ]

class Solution {
    public int minimumDeviation(int[] nums) {
        TreeSet<Integer> set=new TreeSet<>();
        for(int i:nums)
        {
            if((i&1)==1)
                set.add(i*2);
            else set.add(i);
            
            
        }
        int ans=Integer.MAX_VALUE;
        while(true){
            int min=set.first();
            int max=set.pollLast();
            ans=Math.min(ans,max-min);
            if((max&1)==1) break;
            set.add(max/2);
            
            
        }
        
        
        
        return ans;
    }
}



21 . https://www.geeksforgeeks.org/minimize-count-of-divisions-by-d-to-obtain-at-least-k-equal-array-elements/# [[[[[  VVVVVVVV IMP ]]]]]]


import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class EqualizeTheArray {


    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        int n=scanner.nextInt();
        int k=scanner.nextInt();
        int d=scanner.nextInt();
        int []data=new int[n];
        for (int i=0;i<n;i++) data[i]=scanner.nextInt();
        int max=data[0];
        for(int i=1;i<n;i++)
            max=Math.max(max,data[i]);
        ArrayList<Integer>[] temp=new ArrayList[max+1];
        for(int i=0;i<max+1;i++)
            temp[i]=new ArrayList<>();
        for (int i=0;i<n;i++){
            temp[data[i]].add(0);
            int count=0;
            while(data[i]>0){
                data[i]/=d;
                count++;
                temp[data[i]].add(count);
            }
        }
        int ans=Integer.MAX_VALUE;
        for(int i=0;i<=max;i++){
            if(temp[i].size()>=k) {
                Collections.sort(temp[i]);
                int sum=0;
                for(int j=0;j<k;j++)
                    sum+=temp[i].get(j);
                ans=Math.min(ans,sum);
            }

        }
        System.out.println("Answer is "+ans);

    }

}





22.  https://leetcode.com/problems/linked-list-random-node/solution/






23 . N Equal Partitions Problem Intituation [ https://leetcode.com/problems/matchsticks-to-square/ ]

===============      DP + BITMASKING   ====================== 


class Solution {
    int side = 0;
    HashMap<Pair<Integer,Integer>,Boolean> map = new HashMap<>();
    public boolean makesquare(int[] matchsticks) {
      int sum = 0;
      for(int i :matchsticks)
          sum+=i;
      if(sum%4!=0) return false;
        side = sum/4;
      return helper(matchsticks,0,0);
    }
    boolean helper(int [] matchsticks,int mask , int done){
        int total = 0;
        int n = matchsticks.length;
        Pair <Integer,Integer>pair = new Pair<>(mask,done);
        if(map.containsKey(pair)) return map.get(pair);
        for(int i =0 ; i<n ;i++)
        {
            if((mask&(1<<i))!=0)
                total+=matchsticks[i];
        }
        if(total>0&&total%side==0)
            done++;
        if(done==3) return true;
        
        int rem = (done+1)*side- total;
        for(int i =0;i<n;i++){
            if((mask&(1<<i))==0 && matchsticks[i]<=rem)
            {
                if(helper(matchsticks,mask^(1<<i),done)){
                    {
                        map.put(pair,true);
                        return true;
                    }
                }
            }
        }
        map.put(pair,false);
        return false;
    }
}














ZIG ZAG CONVERSION ( https://leetcode.com/problems/zigzag-conversion/ )

https://youtu.be/Q2Tw6gcVEwc










https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/ [ IMP ]
solution - https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/discuss/2551895/JAVA-oror-Easy-Solution-With-Explanation-oror-93-Faster-Code



https://leetcode.com/problems/maximum-performance-of-a-team/ [ IMP ]



https://practice.geeksforgeeks.org/problems/bst-to-max-heap/1 


[ IMP POINT -> IF WE NEED TO KNOW WHETHER THE OCURRENCE IS ODD OR EVEN FOR LIMITED NUMBERS LIKE FOR TOTAL 64 NUMBERS THEN WE SHOULD USE BIT MANIPULATION WHERE CORRESPONDIGN 1 BIT SHOWS IT ODD TIME OCCURS OTHERWISE EVEN TIMES ]


2^n ke sabhi factors 2 ki power ke hi honge [   2*2*2*2*2*...n times if we group them in any way we would get factors in power of 2 ]
how to check whether a number is power of 2 :-> [ https://www.ritambhara.in/check-if-number-is-a-power-of-2/#:~:text=Keep%20dividing%20the%20number%20by,is%20a%20power%20of%202. ]

