As we know 
byte - 1 byte 
short - 2 bytes 
char - 2 bytes 
int - 4 bytes 
long - 8 bytes 
float - 4 bytes
double - 8 bytes 
boolean size varies according to jvm - 1 byte in most of the case
Note : we can not convert boolean to any type and any type to boolean and  boolean is not 0 or 1 in java
using implicit type conversions we can not do :
 can not assign higher type value to lower type value except special cases mentioned later
order is : byte < short != char < int < long < float < double it is not according to bytes it is according to their ranges 
short represent -> -number to +number but char represent 0 to number

         
         

using implicit type conversion we can do :


higher type value = lower type  value [ Note : range also matters so do not hurry see example shown below for details explanation ]


public class Main
{
	public static void main(String[] args) {
	    byte ui=90;
	    char a=ui;
		System.out.println("Hello World");
	}
}
// it is an error




but not hold with short and char bcz of their range if variable is used in the right hand side
long = int true
float =long true
double =float true
int =long false
float =double false
char = byte true if does not contain variable bcz byte range also contain negative number but char does not contain negative number
short = char true if char is literal and within range otherwise error example short a='1';
char = short true if short is literal  and within range  example char a=(short)10

Now there are some special case exist between short , byte , integer , char [ note: this case does not exist with others ]  ->
if higher  type is literal and within the range  then we can assign to lower
for ex : char a= 20 (integer type );
         byte b=20 integer type ;
         short c= 90 (integer type)
         byte d=567; it is error bcz it is not in range of byte
         byte d=(short)56; // correct
         byte d =(char)56; //correct
         if right hand side include any variable (address) then this special case will not hold anymore 
         for example:
         int a=1;
         char b=a; (error)
         if the higher type of right hand side is any of char, byte , short it is always automatically converted into integer type ( literal if not contain any address otherwise simple integer type)
         this special case is not hold with long , double , float 








Note : this special case not hold in function parameter and argument case

Example : ->
 static void okay(int y,int op)
    {

        System.out.println("One");
    }

okay(90,90) ; //correct


static void okay(int y,byte op)
    {

        System.out.println("One");
    }

okay(90,90) ; //error

static void okay(int y,short op)
    {

        System.out.println("One");
    }

okay(90,90) ; //error


static void okay(int y,char op)
    {

        System.out.println("One");
    }

okay(90,90) ; //error


so to avoid this we have to explicitly type cast the value like (byte)90 .






using explicit type conversion we can do anything except boolean conversions.


note suffix for literal types : ->


long - l 
double - d (default suffix with all . number if f is not used )
float  - f


hexadecimal - 0xa1161;
binary - 0b101010;
octal 01717; 


long t=940;  // long is greater so it is correct

But Long t=940; // Error [ Bcz in autoboxing or unboxing the type must be exactly same  whether in simple statement or passing as arguments ]
Long t= 940l; // Correct
int op=(int)t; // Error // bcz Long can be unboxed to long primitive type
int op=(int)(long)t; // Correct










byte temp;
temp=temp==1|| match(s,p,i+1,j)==1||match(s,p,i+1,j+2)==1?(byte)1:(byte)0; // Very special case agar byte type casting htaye to error aayega   









0x00 and 0x01 are int literals: they are expressions with int type. An int can't usually be assigned to a byte, but it can if the expression is compile-time constant, provided the value is in the range of byte.

With the conditional, the assigned value is compile-time constant:

if (enabled) {
  enabledByte = 0x01;
} else {
  enabledByte = 0x00;
}
These assignments are completely separate from the compiler's point of view. There is one statement which assigns the constant value 1, and one statement which assigns the constant value 0.

For each statement, the compiler can guarantee that fits into the range of byte, so it automatically narrows the assigned value to byte.

However, the assignment with the conditional operator:

enabledByte = enabled ? 0x01 : 0x00;
The rhs expression is of type int, but isn't compile time constant, because enabled isn't known at compile time. It doesn't matter that the two possible values are compile-time constant, and both would fit into a byte: the non-constant first operand makes it non-constant. As such, the result of the conditional operator expression cannot be automatically narrowed.

The most efficient solution to this is to cast the second and third operands to byte:

enabled ? (byte) 0x01 : (byte) 0x00
This is better than

(byte) (enabled ? 0x01 : 0x00)
Because the latter will cast at runtime, each time the expression is evaluated, whereas the former does not: the operands are already bytes at compile-time, so no cast is necessary.
