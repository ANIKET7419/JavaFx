Syntax:

for (type var : array)
{
    statements using var;
}


is equivalent to:

for (int i=0; i<arr.length; i++)
{
    type var = arr[i];
    statements using var;
}


Example:
int i;
for(i:arr){} //ERROR   [   Error:  bad initializer for for-loop ]


for(int i:arr){} //CORRECT




Limitations of for-each loop

For-each loops are not appropriate when you want to modify the array:
for (int num : marks)
{
    // only changes num, not the array element
    num = num*2;
}
For-each loops do not keep track of index. So we can not obtain array index using For-Each loop
for (int num : numbers)
{
    if (num == target)
    {
        return ???;   // do not know the index of num
    }
}
For-each only iterates forward over the array in single steps
// cannot be converted to a for-each loop
for (int i=numbers.length-1; i>0; i--)
{
      System.out.println(numbers[i]);
}
For-each cannot process two decision making statements at once
// cannot be easily converted to a for-each loop
for (int i=0; i<numbers.length; i++)
{
    if (numbers[i] == arr[i])
    { ...
    }
}





There are two possible reasons to do this:

It could simply be a way to avoid changing the loop variable accidentally in the loop body. (Or to document the fact that the loop variable is not going to be changed.)

It could be done so that you can refer to the loop variable in an anonymous inner class. For example:

for(final Animal animal : animalList){
    executor.submit(new Runnable(){
        public void run() {
            animal.feed();
        }
    });
}
It is a compilation error if you leave out the final in this example.

UPDATE it is not a compilation error in Java 8 and later versions. The non-local variable is now only required to be effectively final. In simple terms, that means that the variable is not assigned to (using an assignment operator or a pre/post increment or decrement operator) after the initial declaration / initialization.
